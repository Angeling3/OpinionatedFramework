using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using IOKode.OpinionatedFramework.SourceGenerators.Helpers;

namespace IOKode.OpinionatedFramework.SourceGenerators.SqlQueryObjects;

public partial class QueryObjectsGenerator
{
    private class ConfigOptions
    {
        public string RootNamespace { get; set; }
        public string RootPath { get; set; }
    }

    private class SqlFile
    {
        public string FilePath { get; set; }
        public string Content { get; set; }
    }

    private class QueryObjectClass
    {
        public SqlFile SqlFile { get; }
        public ConfigOptions ConfigOptions { get; }
        public string Name => Path.GetFileNameWithoutExtension(SqlFile.FilePath);
        public string ClassName => Name.EndsWith("Query") ? Name : $"{Name}Query";
        public string FileName => $"{ClassName}.g.cs";

        public string Namespace => _GetNamespace();
        public string QueryContent => SqlFile.Content;
        public bool IsSingleResult => Regex.IsMatch(SqlFile.Content, _QueryIsSingleResultRegex);
        public bool IsSingleOrDefaultResult => Regex.IsMatch(SqlFile.Content, _QueryIsSingleOrDefaultResultRegex);

        public ParameterType[] QueryParameters;
        public ParameterType[] ResultParameters;
        public string QueryResultClassName => $"{ClassName}Result";
        private readonly string _QueryParameterRegex = @"--\s*@parameter\s+([\w.]+(?:\?)?)\s+(\w+)";
        private readonly string _QueryResultParameterRegex = @"--\s*@result\s+([\w.]+(?:\?)?)\s+(\w+)";
        private readonly string _QueryNamespaceParameterRegex = @"--\s*@namespace\s+([\w.]+)";
        private readonly string _QueryIsSingleResultRegex = @"--\s*@single(?!\w)";
        private readonly string _QueryIsSingleOrDefaultResultRegex = @"--\s*@single_or_default";

        public QueryObjectClass(SqlFile sqlFile, ConfigOptions configOptions)
        {
            SqlFile = sqlFile;
            ConfigOptions = configOptions;
            var queryParameterMatches = Regex.Matches(sqlFile.Content, _QueryParameterRegex);
            var queryResultParameterMatches = Regex.Matches(sqlFile.Content, _QueryResultParameterRegex);

            QueryParameters = queryParameterMatches
                .Cast<Match>()
                .Select(match => new ParameterType
                {
                    Type = match.Groups[1].Value,
                    Name = match.Groups[2].Value
                })
                .ToArray();

            ResultParameters = queryResultParameterMatches
                .Cast<Match>()
                .Select(match => new ParameterType
                {
                    Type = match.Groups[1].Value,
                    Name = match.Groups[2].Value
                })
                .ToArray();
        }

        private string _GetNamespace()
        {
            var queryNamespaceMatches = Regex.Matches(SqlFile.Content, _QueryNamespaceParameterRegex);
            var namespaceInFile = queryNamespaceMatches.Cast<Match>().FirstOrDefault()?.Groups[1].Value;
            if (!string.IsNullOrWhiteSpace(namespaceInFile))
            {
                return namespaceInFile;
            }

            var rootPathName = ConfigOptions.RootPath.TrimEnd(Path.DirectorySeparatorChar);
            var fileDirectoryPath = Path.GetDirectoryName(SqlFile.FilePath) ?? string.Empty;
            int startRootPathIndex = fileDirectoryPath.IndexOf(rootPathName, StringComparison.InvariantCultureIgnoreCase);
            string relativePath = fileDirectoryPath.Substring(startRootPathIndex + rootPathName.Length);
            string relativeNamespace = relativePath.Replace(Path.DirectorySeparatorChar, '.').Trim('.');

            return string.IsNullOrWhiteSpace(relativeNamespace)
                ? ConfigOptions.RootNamespace
                : $"{ConfigOptions.RootNamespace}.{relativeNamespace}";
        }
    }

    private class ParameterType
    {
        public string Name { get; set; }
        public string Type { get; set; }
        public string PascalCaseName => Name.ToPascalCase();
        public string CamelCaseName => Name.ToCamelCase();
    }

    private const string _QueryObjectClassTemplate =
        """"
        // This file was auto-generated by a source generator

        #nullable enable
        using System.Collections.Generic;
        using System.Linq;
        using System.Threading;
        using System.Threading.Tasks;
        using IOKode.OpinionatedFramework;
        using IOKode.OpinionatedFramework.Persistence.Queries;

        namespace {{ Namespace }};

        public static partial class {{ ClassName }}
        {
            public const string Query =
                """
                {{ QueryContent }}
                """;

            public static async Task<{{ if IsSingleResult }}{{ QueryResultClassName }}{{ else if IsSingleOrDefaultResult }}{{ QueryResultClassName }}?{{ else }}IReadOnlyCollection<{{ QueryResultClassName }}>{{ end }}> InvokeAsync({{ for parameter in QueryParameters }}{{ parameter.Type }} {{ parameter.CamelCaseName }},{{ end }} CancellationToken cancellationToken)
            {
                var queryExecutor = Locator.Resolve<IQueryExecutor>();
                var parameters = new
                {
                    {{~ for parameter in QueryParameters ~}}
                    {{ parameter.Name }} = {{ parameter.CamelCaseName }},
                    {{~ end ~}}
                };

                {{~ if IsSingleResult ~}}
                var queryResult = await queryExecutor.QuerySingleAsync<_QueryResult>(Query, parameters, null, cancellationToken);
                var result = _MapQueryResult(queryResult);
                {{~ else if IsSingleOrDefaultResult ~}}
                var queryResult = await queryExecutor.QuerySingleOrDefaultAsync<_QueryResult>(Query, parameters, null, cancellationToken);
                var result = queryResult == null ? default : _MapQueryResult(queryResult);
                {{~ else ~}}
                var queryResult = await queryExecutor.QueryAsync<_QueryResult>(Query, parameters, null, cancellationToken);
                var result = queryResult.Select(_MapQueryResult).ToArray();
                {{~ end ~}}
                return result;
            }

            private static {{ QueryResultClassName }} _MapQueryResult(_QueryResult queryResult)
            {
                return new {{ QueryResultClassName }}
                {
                    {{~ for parameter in ResultParameters ~}}
                    {{ parameter.PascalCaseName }} = queryResult.{{ parameter.Name }},
                    {{~ end ~}}
                };
            }
            
            private class _QueryResult
            {
                {{~ for parameter in ResultParameters ~}}
                public {{ parameter.Type }} {{ parameter.Name }} { get; set; }
                {{~ end ~}}
            }
        }

        public record {{ QueryResultClassName }}
        {
            {{~ for parameter in ResultParameters ~}}
            public required {{ parameter.Type }} {{ parameter.PascalCaseName }} { get; init; }
            {{~ end ~}}
        }
        """";
}
